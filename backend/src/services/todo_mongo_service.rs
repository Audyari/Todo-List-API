use crate::models::todo::{CreateTodoRequest, Todo, UpdateTodoRequest};
use bson::oid::ObjectId;
use chrono::Utc;
use futures_util::stream::TryStreamExt;
use mongodb::{bson::doc, Collection};

pub struct TodoMongoService {
    collection: Collection<Todo>,
}

impl TodoMongoService {
    pub fn new(db: &mongodb::Database) -> Self {
        let collection: Collection<Todo> = db.collection("todos");
        TodoMongoService { collection }
    }

    pub async fn get_all_todos(&self) -> Result<Vec<Todo>, mongodb::error::Error> {
        let mut cursor = self.collection.find(None, None).await?;
        let mut todos = Vec::new();

        while let Some(todo) = cursor.try_next().await? {
            todos.push(todo);
        }

        Ok(todos)
    }

    pub async fn get_todo_by_id(
        &self,
        id: ObjectId,
    ) -> Result<Option<Todo>, mongodb::error::Error> {
        self.collection.find_one(doc! { "_id": id }, None).await
    }

    pub async fn create_todo(
        &self,
        todo: CreateTodoRequest,
    ) -> Result<Todo, mongodb::error::Error> {
        let new_todo = Todo {
            id: None, // ObjectId will be generated by MongoDB
            title: todo.title,
            description: todo.description,
            completed: false,
            created_at: Some(Utc::now()),
            updated_at: Some(Utc::now()),
        };

        let result = self.collection.insert_one(new_todo.clone(), None).await?;
        let inserted_id = result.inserted_id.as_object_id().unwrap();

        // Return the todo with the generated ID
        let mut todo_with_id = new_todo;
        todo_with_id.id = Some(inserted_id);

        Ok(todo_with_id)
    }

    pub async fn update_todo(
        &self,
        id: ObjectId,
        updates: UpdateTodoRequest,
    ) -> Result<Option<Todo>, mongodb::error::Error> {
        let mut update_doc = doc! {};

        if let Some(title) = updates.title {
            update_doc.insert("title", title);
        }

        if let Some(description) = updates.description {
            update_doc.insert("description", description);
        }

        if let Some(completed) = updates.completed {
            update_doc.insert("completed", completed);
        }

        update_doc.insert("updatedAt", Utc::now());

        let result = self
            .collection
            .find_one_and_update(doc! { "_id": id }, doc! { "$set": update_doc }, None)
            .await?;

        Ok(result)
    }

    pub async fn delete_todo(&self, id: ObjectId) -> Result<bool, mongodb::error::Error> {
        let result = self.collection.delete_one(doc! { "_id": id }, None).await?;
        Ok(result.deleted_count == 1)
    }
}
